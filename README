== Use cases: ==

(a) // Checkout and build everything
$ aBuild git@github.com:DemoProject1.git # checksout and builds everything you need

(b) // Rebuild everything
$ cd DemoProjct1
$ aBuild

(c) // Update everything
$ cd DemoProject1
$ aBuild pull

(d) // Test everything
$ cd DemoProject1
$ aBuild test

(e) // Create docu
$ cd DemoProject1
$ aBuild docu

== Progress ==
Progress:
(a) o
(b) o
(c) o
(d) o
(e) o


!!TODOs
– High Priority
	• more advanced toolchain selection
		– using external sdk
		– are sdk and toolchain the samething? (no, since sdk is only headrs, while toolchain can be a cross compiler)
	• resolving library dependencies (at the moment it's done with weird settings on compiler level)
	• parallel compiling
	• using generation dependencies, so already generated cpp files don't get regenerated
	• Providing easy to use toolchains generated from pc directly

– Low priority
	• "including" dep ext dependencies
		This would allow a flat package hierachy.
		So we could have meta packages which provide all types of utils,
		but we don't need to know each real package name.
		(using own namespace, so there can be meta packages)
	   "depLibraries" should get a new name, they should be transitive
	• loop detection of projects
		dependencies of projects
	• status (which also shows unpushed changes)
	• display dependency tree
	• use a git library
	• use CommonOption library (some decision about dynamic parameters have to be made)
	• use better library for file operations
	• plugins for own file formats
		- can we compile stuff that's not c/c++?
	• installing and finding packages on system?
	• fixing overuse of "system()"
	• handle url changes of packages, Idea: delete packages and redownload it
	• generating docu
	• testing in docker (no clue how yet)
	• rewrite url rules or package url rules
